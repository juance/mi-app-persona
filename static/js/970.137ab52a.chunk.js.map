{"version":3,"file":"static/js/970.137ab52a.chunk.js","mappings":"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","sources":["utils/validation.js","services/localPersistenceService.js","services/localDataService.js","services/transactionService.js","services/advancedCacheService.js","components/common/AnimatedButton.js"],"sourcesContent":["/**\n * Valida un email\n * @param {string} email - Email a validar\n * @returns {boolean} - true si el email es válido\n */\nexport const isValidEmail = (email) => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\n/**\n * Valida una contraseña\n * @param {string} password - Contraseña a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validatePassword = (password) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!password || password.length < 6) {\n    result.isValid = false;\n    result.errors.push('La contraseña debe tener al menos 6 caracteres');\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    result.isValid = false;\n    result.errors.push('La contraseña debe contener al menos una letra mayúscula');\n  }\n  \n  if (!/[0-9]/.test(password)) {\n    result.isValid = false;\n    result.errors.push('La contraseña debe contener al menos un número');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una transacción\n * @param {Object} transaction - Transacción a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateTransaction = (transaction) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!transaction.title || transaction.title.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El título es obligatorio');\n  }\n  \n  if (!transaction.amount || isNaN(transaction.amount) || transaction.amount <= 0) {\n    result.isValid = false;\n    result.errors.push('El monto debe ser un número mayor que cero');\n  }\n  \n  if (!transaction.type || !['income', 'expense'].includes(transaction.type)) {\n    result.isValid = false;\n    result.errors.push('El tipo debe ser ingreso o gasto');\n  }\n  \n  if (!transaction.date) {\n    result.isValid = false;\n    result.errors.push('La fecha es obligatoria');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una tarea\n * @param {Object} task - Tarea a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateTask = (task) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!task.title || task.title.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El título es obligatorio');\n  }\n  \n  if (task.priority && !['low', 'medium', 'high'].includes(task.priority)) {\n    result.isValid = false;\n    result.errors.push('La prioridad debe ser baja, media o alta');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una inversión\n * @param {Object} investment - Inversión a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateInvestment = (investment) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!investment.name || investment.name.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El nombre es obligatorio');\n  }\n  \n  if (!investment.symbol || investment.symbol.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El símbolo es obligatorio');\n  }\n  \n  if (!investment.type || investment.type.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El tipo es obligatorio');\n  }\n  \n  if (!investment.quantity || isNaN(investment.quantity) || investment.quantity <= 0) {\n    result.isValid = false;\n    result.errors.push('La cantidad debe ser un número mayor que cero');\n  }\n  \n  if (!investment.purchase_price || isNaN(investment.purchase_price) || investment.purchase_price <= 0) {\n    result.isValid = false;\n    result.errors.push('El precio de compra debe ser un número mayor que cero');\n  }\n  \n  if (!investment.current_price || isNaN(investment.current_price) || investment.current_price <= 0) {\n    result.isValid = false;\n    result.errors.push('El precio actual debe ser un número mayor que cero');\n  }\n  \n  if (!investment.purchase_date) {\n    result.isValid = false;\n    result.errors.push('La fecha de compra es obligatoria');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una meta financiera\n * @param {Object} goal - Meta financiera a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateFinancialGoal = (goal) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!goal.name || goal.name.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El nombre es obligatorio');\n  }\n  \n  if (!goal.target_amount || isNaN(goal.target_amount) || goal.target_amount <= 0) {\n    result.isValid = false;\n    result.errors.push('El monto objetivo debe ser un número mayor que cero');\n  }\n  \n  if (goal.current_amount && (isNaN(goal.current_amount) || goal.current_amount < 0)) {\n    result.isValid = false;\n    result.errors.push('El monto actual debe ser un número mayor o igual a cero');\n  }\n  \n  return result;\n};\n\n/**\n * Valida un evento\n * @param {Object} event - Evento a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateEvent = (event) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!event.title || event.title.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El título es obligatorio');\n  }\n  \n  if (!event.date) {\n    result.isValid = false;\n    result.errors.push('La fecha es obligatoria');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una categoría\n * @param {Object} category - Categoría a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validateCategory = (category) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!category.name || category.name.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El nombre es obligatorio');\n  }\n  \n  if (!category.type || !['income', 'expense', 'task', 'investment', 'event'].includes(category.type)) {\n    result.isValid = false;\n    result.errors.push('El tipo debe ser válido');\n  }\n  \n  return result;\n};\n\n/**\n * Valida una plataforma\n * @param {Object} platform - Plataforma a validar\n * @returns {Object} - Objeto con el resultado de la validación\n */\nexport const validatePlatform = (platform) => {\n  const result = {\n    isValid: true,\n    errors: []\n  };\n  \n  if (!platform.name || platform.name.trim() === '') {\n    result.isValid = false;\n    result.errors.push('El nombre es obligatorio');\n  }\n  \n  if (!platform.type || !['cash', 'virtual'].includes(platform.type)) {\n    result.isValid = false;\n    result.errors.push('El tipo debe ser efectivo o virtual');\n  }\n  \n  return result;\n};\n","/**\n * Servicio para persistencia local directa\n * Este servicio proporciona una capa adicional de persistencia\n * para asegurar que los datos críticos no se pierdan\n */\n\n// Prefijo para las claves de almacenamiento\nconst STORAGE_PREFIX = 'mi_app_personal_direct_';\n\n/**\n * Guardar transacciones en localStorage\n * @param {string} userId - ID del usuario\n * @param {Array} transactions - Transacciones a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveTransactionsToLocalStorage = (userId, transactions) => {\n  if (!userId || !transactions) {\n    console.error('Se requiere userId y transactions para guardar en localStorage');\n    return false;\n  }\n  \n  try {\n    // Guardar con timestamp para saber cuándo se guardaron\n    const data = {\n      transactions,\n      timestamp: Date.now(),\n      count: transactions.length\n    };\n    \n    const key = `${STORAGE_PREFIX}transactions_${userId}`;\n    localStorage.setItem(key, JSON.stringify(data));\n    \n    console.log(`Guardadas ${transactions.length} transacciones en localStorage para el usuario ${userId}`);\n    return true;\n  } catch (error) {\n    console.error('Error al guardar transacciones en localStorage:', error);\n    return false;\n  }\n};\n\n/**\n * Obtener transacciones de localStorage\n * @param {string} userId - ID del usuario\n * @returns {Array} - Transacciones guardadas o array vacío\n */\nexport const getTransactionsFromLocalStorage = (userId) => {\n  if (!userId) {\n    console.error('Se requiere userId para obtener transacciones de localStorage');\n    return [];\n  }\n  \n  try {\n    const key = `${STORAGE_PREFIX}transactions_${userId}`;\n    const storedData = localStorage.getItem(key);\n    \n    if (!storedData) {\n      console.log(`No hay transacciones guardadas en localStorage para el usuario ${userId}`);\n      return [];\n    }\n    \n    const data = JSON.parse(storedData);\n    console.log(`Recuperadas ${data.transactions.length} transacciones de localStorage para el usuario ${userId} (guardadas hace ${Math.round((Date.now() - data.timestamp) / 1000 / 60)} minutos)`);\n    \n    return data.transactions || [];\n  } catch (error) {\n    console.error('Error al obtener transacciones de localStorage:', error);\n    return [];\n  }\n};\n\n/**\n * Guardar datos en localStorage\n * @param {string} key - Clave\n * @param {*} data - Datos a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveToLocalStorage = (key, data) => {\n  if (!key) {\n    console.error('Se requiere key para guardar en localStorage');\n    return false;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    localStorage.setItem(fullKey, JSON.stringify(data));\n    return true;\n  } catch (error) {\n    console.error(`Error al guardar ${key} en localStorage:`, error);\n    return false;\n  }\n};\n\n/**\n * Obtener datos de localStorage\n * @param {string} key - Clave\n * @param {*} defaultValue - Valor por defecto\n * @returns {*} - Datos guardados o valor por defecto\n */\nexport const getFromLocalStorage = (key, defaultValue = null) => {\n  if (!key) {\n    console.error('Se requiere key para obtener de localStorage');\n    return defaultValue;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    const storedData = localStorage.getItem(fullKey);\n    \n    if (!storedData) {\n      return defaultValue;\n    }\n    \n    return JSON.parse(storedData);\n  } catch (error) {\n    console.error(`Error al obtener ${key} de localStorage:`, error);\n    return defaultValue;\n  }\n};\n\n/**\n * Eliminar datos de localStorage\n * @param {string} key - Clave\n * @returns {boolean} - true si se eliminó correctamente\n */\nexport const removeFromLocalStorage = (key) => {\n  if (!key) {\n    console.error('Se requiere key para eliminar de localStorage');\n    return false;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    localStorage.removeItem(fullKey);\n    return true;\n  } catch (error) {\n    console.error(`Error al eliminar ${key} de localStorage:`, error);\n    return false;\n  }\n};\n","/**\n * Servicio para almacenamiento local independiente\n * Este servicio proporciona funciones para guardar y recuperar datos\n * localmente sin depender de la autenticación o la base de datos\n */\n\n// Prefijo para las claves de almacenamiento\nconst STORAGE_PREFIX = 'mi_app_personal_local_';\n\n// ID de usuario para modo demo\nexport const DEMO_USER_ID = 'demo_user';\n\n/**\n * Guardar datos en localStorage\n * @param {string} key - Clave\n * @param {*} data - Datos a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveLocalData = (key, data) => {\n  if (!key) {\n    console.error('Se requiere key para guardar en localStorage');\n    return false;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    const dataToSave = {\n      data,\n      timestamp: Date.now()\n    };\n    localStorage.setItem(fullKey, JSON.stringify(dataToSave));\n    console.log(`Datos guardados en localStorage con clave ${key}`);\n    return true;\n  } catch (error) {\n    console.error(`Error al guardar ${key} en localStorage:`, error);\n    return false;\n  }\n};\n\n/**\n * Obtener datos de localStorage\n * @param {string} key - Clave\n * @param {*} defaultValue - Valor por defecto\n * @returns {*} - Datos guardados o valor por defecto\n */\nexport const getLocalData = (key, defaultValue = null) => {\n  if (!key) {\n    console.error('Se requiere key para obtener de localStorage');\n    return defaultValue;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    const storedData = localStorage.getItem(fullKey);\n    \n    if (!storedData) {\n      return defaultValue;\n    }\n    \n    const parsedData = JSON.parse(storedData);\n    console.log(`Datos recuperados de localStorage con clave ${key} (guardados hace ${Math.round((Date.now() - parsedData.timestamp) / 1000 / 60)} minutos)`);\n    return parsedData.data;\n  } catch (error) {\n    console.error(`Error al obtener ${key} de localStorage:`, error);\n    return defaultValue;\n  }\n};\n\n/**\n * Eliminar datos de localStorage\n * @param {string} key - Clave\n * @returns {boolean} - true si se eliminó correctamente\n */\nexport const removeLocalData = (key) => {\n  if (!key) {\n    console.error('Se requiere key para eliminar de localStorage');\n    return false;\n  }\n  \n  try {\n    const fullKey = `${STORAGE_PREFIX}${key}`;\n    localStorage.removeItem(fullKey);\n    console.log(`Datos eliminados de localStorage con clave ${key}`);\n    return true;\n  } catch (error) {\n    console.error(`Error al eliminar ${key} de localStorage:`, error);\n    return false;\n  }\n};\n\n/**\n * Guardar transacciones en localStorage\n * @param {Array} transactions - Transacciones a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveTransactions = (transactions) => {\n  return saveLocalData('transactions', transactions);\n};\n\n/**\n * Obtener transacciones de localStorage\n * @returns {Array} - Transacciones guardadas o array vacío\n */\nexport const getTransactions = () => {\n  return getLocalData('transactions', []);\n};\n\n/**\n * Agregar una transacción a las existentes\n * @param {Object} transaction - Transacción a agregar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const addTransaction = (transaction) => {\n  try {\n    // Generar ID si no tiene\n    const transactionWithId = {\n      ...transaction,\n      id: transaction.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      user_id: transaction.user_id || DEMO_USER_ID,\n      created_at: transaction.created_at || new Date().toISOString()\n    };\n    \n    // Obtener transacciones actuales\n    const currentTransactions = getTransactions();\n    \n    // Agregar la nueva transacción al principio\n    const updatedTransactions = [transactionWithId, ...currentTransactions];\n    \n    // Guardar transacciones actualizadas\n    return saveTransactions(updatedTransactions);\n  } catch (error) {\n    console.error('Error al agregar transacción:', error);\n    return false;\n  }\n};\n\n/**\n * Actualizar una transacción existente\n * @param {string} id - ID de la transacción\n * @param {Object} updates - Datos a actualizar\n * @returns {boolean} - true si se actualizó correctamente\n */\nexport const updateTransaction = (id, updates) => {\n  try {\n    // Obtener transacciones actuales\n    const currentTransactions = getTransactions();\n    \n    // Buscar la transacción\n    const index = currentTransactions.findIndex(t => t.id === id);\n    \n    if (index === -1) {\n      console.error(`No se encontró la transacción con ID ${id}`);\n      return false;\n    }\n    \n    // Actualizar la transacción\n    const updatedTransactions = [...currentTransactions];\n    updatedTransactions[index] = {\n      ...updatedTransactions[index],\n      ...updates,\n      updated_at: new Date().toISOString()\n    };\n    \n    // Guardar transacciones actualizadas\n    return saveTransactions(updatedTransactions);\n  } catch (error) {\n    console.error('Error al actualizar transacción:', error);\n    return false;\n  }\n};\n\n/**\n * Eliminar una transacción\n * @param {string} id - ID de la transacción\n * @returns {boolean} - true si se eliminó correctamente\n */\nexport const deleteTransaction = (id) => {\n  try {\n    // Obtener transacciones actuales\n    const currentTransactions = getTransactions();\n    \n    // Filtrar la transacción a eliminar\n    const updatedTransactions = currentTransactions.filter(t => t.id !== id);\n    \n    // Si no se eliminó ninguna transacción, retornar false\n    if (updatedTransactions.length === currentTransactions.length) {\n      console.error(`No se encontró la transacción con ID ${id}`);\n      return false;\n    }\n    \n    // Guardar transacciones actualizadas\n    return saveTransactions(updatedTransactions);\n  } catch (error) {\n    console.error('Error al eliminar transacción:', error);\n    return false;\n  }\n};\n\n/**\n * Guardar tareas en localStorage\n * @param {Array} tasks - Tareas a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveTasks = (tasks) => {\n  return saveLocalData('tasks', tasks);\n};\n\n/**\n * Obtener tareas de localStorage\n * @returns {Array} - Tareas guardadas o array vacío\n */\nexport const getTasks = () => {\n  return getLocalData('tasks', []);\n};\n\n/**\n * Guardar eventos en localStorage\n * @param {Array} events - Eventos a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveEvents = (events) => {\n  return saveLocalData('events', events);\n};\n\n/**\n * Obtener eventos de localStorage\n * @returns {Array} - Eventos guardados o array vacío\n */\nexport const getEvents = () => {\n  return getLocalData('events', []);\n};\n\n/**\n * Guardar inversiones en localStorage\n * @param {Array} investments - Inversiones a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveInvestments = (investments) => {\n  return saveLocalData('investments', investments);\n};\n\n/**\n * Obtener inversiones de localStorage\n * @returns {Array} - Inversiones guardadas o array vacío\n */\nexport const getInvestments = () => {\n  return getLocalData('investments', []);\n};\n\n/**\n * Guardar metas financieras en localStorage\n * @param {Array} goals - Metas financieras a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveFinancialGoals = (goals) => {\n  return saveLocalData('financial_goals', goals);\n};\n\n/**\n * Obtener metas financieras de localStorage\n * @returns {Array} - Metas financieras guardadas o array vacío\n */\nexport const getFinancialGoals = () => {\n  return getLocalData('financial_goals', []);\n};\n\n/**\n * Guardar categorías en localStorage\n * @param {Array} categories - Categorías a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const saveCategories = (categories) => {\n  return saveLocalData('categories', categories);\n};\n\n/**\n * Obtener categorías de localStorage\n * @returns {Array} - Categorías guardadas o array vacío\n */\nexport const getCategories = () => {\n  return getLocalData('categories', []);\n};\n\n/**\n * Guardar plataformas en localStorage\n * @param {Array} platforms - Plataformas a guardar\n * @returns {boolean} - true si se guardó correctamente\n */\nexport const savePlatforms = (platforms) => {\n  return saveLocalData('platforms', platforms);\n};\n\n/**\n * Obtener plataformas de localStorage\n * @returns {Array} - Plataformas guardadas o array vacío\n */\nexport const getPlatforms = () => {\n  return getLocalData('platforms', []);\n};\n","import { supabase } from './supabase';\nimport { validateTransaction } from '../utils/validation';\nimport {\n  getCachedValue,\n  setCachedValue,\n  removeCachedValue,\n  withCache,\n  prefetchCache\n} from './advancedCacheService';\nimport {\n  saveToIndexedDB,\n  getFromIndexedDB,\n  deleteFromIndexedDB,\n  addToSyncQueue,\n  checkOnlineStatus\n} from './offlineStorage';\nimport {\n  saveTransactionsToLocalStorage,\n  getTransactionsFromLocalStorage\n} from './localPersistenceService';\nimport {\n  getTransactions as getLocalTransactions,\n  addTransaction as addLocalTransaction,\n  updateTransaction as updateLocalTransaction,\n  deleteTransaction as deleteLocalTransaction,\n  DEMO_USER_ID\n} from './localDataService';\n\nexport const getTransactions = async () => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    // Si no hay usuario, usar el almacenamiento local independiente\n    if (!user) {\n      console.log('No authenticated user found, using local storage');\n      const localTransactions = getLocalTransactions();\n      console.log(`Obtenidas ${localTransactions.length} transacciones del almacenamiento local independiente`);\n      return localTransactions;\n    }\n\n    // Clave de caché basada en el ID del usuario\n    const cacheKey = `transactions_${user.id}`;\n\n    // Primero, intentar obtener datos del localStorage (persistencia directa)\n    const localStorageData = getTransactionsFromLocalStorage(user.id);\n\n    // Si hay datos en localStorage, usarlos mientras se cargan los datos actualizados\n    let initialData = localStorageData.length > 0 ? localStorageData : [];\n\n    // Función para obtener datos de Supabase\n    const fetchFromSupabase = async () => {\n      console.log('Fetching transactions from Supabase');\n      const { data, error } = await supabase\n        .from('transactions')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('date', { ascending: false });\n\n      if (error) {\n        console.error('Error fetching transactions from Supabase:', error);\n        throw error;\n      }\n\n      // Guardar en IndexedDB para acceso offline\n      const result = data || [];\n      if (result.length > 0) {\n        console.log(`Guardando ${result.length} transacciones en IndexedDB`);\n        await saveToIndexedDB('transactions', result);\n\n        // Guardar también en localStorage para persistencia directa\n        saveTransactionsToLocalStorage(user.id, result);\n      } else {\n        console.log('No hay transacciones para guardar en IndexedDB');\n      }\n\n      return result;\n    };\n\n    // Función para obtener datos de IndexedDB\n    const fetchFromIndexedDB = async () => {\n      console.log('Fetching transactions from IndexedDB');\n      try {\n        const localData = await getFromIndexedDB('transactions');\n        console.log(`Obtenidas ${localData.length} transacciones de IndexedDB`);\n        const userTransactions = localData.filter(t => t.user_id === user.id);\n        console.log(`Filtradas ${userTransactions.length} transacciones del usuario ${user.id}`);\n\n        // Si hay datos en IndexedDB, guardarlos también en localStorage\n        if (userTransactions.length > 0) {\n          saveTransactionsToLocalStorage(user.id, userTransactions);\n        }\n\n        return userTransactions;\n      } catch (err) {\n        console.error('Error al obtener transacciones de IndexedDB:', err);\n        return initialData; // Usar datos de localStorage si hay error\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, intentar obtener datos con caché\n      try {\n        // Primero verificar si hay datos en IndexedDB\n        const localData = await fetchFromIndexedDB();\n\n        // Si no hay datos en IndexedDB o son pocos, forzar obtención desde Supabase\n        if (localData.length < 5) {\n          console.log('Pocos datos en IndexedDB, obteniendo desde Supabase');\n          const onlineData = await fetchFromSupabase();\n\n          // Almacenar en caché\n          setCachedValue(cacheKey, onlineData, 5 * 60 * 1000, { priority: true });\n\n          return onlineData;\n        }\n\n        // Si hay suficientes datos en IndexedDB, usar caché normal\n        const result = await withCache(\n          fetchFromSupabase,\n          cacheKey,\n          5 * 60 * 1000, // 5 minutos de TTL\n          { priority: true } // Prioridad alta para evitar evicción\n        );\n\n        return result;\n      } catch (error) {\n        console.error('Error fetching from Supabase with cache:', error);\n        // Si hay error, intentar obtener datos de IndexedDB\n        const indexedDBData = await fetchFromIndexedDB();\n\n        // Si no hay datos en IndexedDB, usar datos de localStorage\n        return indexedDBData.length > 0 ? indexedDBData : initialData;\n      }\n    } else {\n      // Si no hay conexión, obtener datos de IndexedDB\n      console.log('Offline mode: using IndexedDB');\n      const localData = await fetchFromIndexedDB();\n\n      // Si no hay datos en IndexedDB, usar datos de localStorage\n      const finalData = localData.length > 0 ? localData : initialData;\n\n      // Almacenar en caché con TTL más largo para modo offline\n      setCachedValue(cacheKey, finalData, 30 * 60 * 1000, { priority: true });\n\n      return finalData;\n    }\n  } catch (error) {\n    console.error('Error in getTransactions:', error);\n\n    // Intentar obtener datos de IndexedDB en caso de error\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (user) {\n        // Primero intentar IndexedDB\n        try {\n          const localData = await getFromIndexedDB('transactions');\n          const userTransactions = localData.filter(t => t.user_id === user.id);\n          if (userTransactions.length > 0) {\n            return userTransactions;\n          }\n        } catch (err) {\n          console.error('Error fetching from IndexedDB:', err);\n        }\n\n        // Si falla IndexedDB, intentar localStorage\n        const localStorageData = getTransactionsFromLocalStorage(user.id);\n        if (localStorageData.length > 0) {\n          return localStorageData;\n        }\n      }\n    } catch (err) {\n      console.error('Error fetching user or local data:', err);\n    }\n\n    // Si todo falla, usar el almacenamiento local independiente\n    console.log('Fallback to local storage');\n    return getLocalTransactions();\n  }\n};\n\n// Prefetch de transacciones para mejorar la experiencia del usuario\nexport const prefetchTransactions = async () => {\n  try {\n    const { data: { user } } = await supabase.auth.getUser();\n\n    if (!user) return false;\n\n    const cacheKey = `transactions_${user.id}`;\n\n    // Función para obtener datos\n    const fetchData = async () => {\n      const { data, error } = await supabase\n        .from('transactions')\n        .select('*')\n        .eq('user_id', user.id)\n        .order('date', { ascending: false });\n\n      if (error) throw error;\n\n      // Guardar en IndexedDB\n      await saveToIndexedDB('transactions', data || []);\n\n      return data || [];\n    };\n\n    // Prefetch con TTL de 5 minutos\n    return await prefetchCache(fetchData, cacheKey, 5 * 60 * 1000);\n  } catch (error) {\n    console.error('Error in prefetchTransactions:', error);\n    return false;\n  }\n};\n\n/**\n * Obtiene una transacción por su ID\n * @param {number} id - ID de la transacción\n * @returns {Promise<Object>} - Transacción encontrada o null\n */\nexport const getTransactionById = async (id) => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Clave de caché\n    const cacheKey = `transaction_${id}`;\n\n    // Función para obtener datos de Supabase\n    const fetchFromSupabase = async () => {\n      const { data, error } = await supabase\n        .from('transactions')\n        .select('*')\n        .eq('id', id)\n        .eq('user_id', user.id)\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      return data;\n    };\n\n    // Función para obtener datos de IndexedDB\n    const fetchFromIndexedDB = async () => {\n      try {\n        return await getFromIndexedDB('transactions', id);\n      } catch (err) {\n        return null;\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, intentar obtener datos con caché\n      try {\n        // Usar withCache para manejar automáticamente la caché\n        return await withCache(\n          fetchFromSupabase,\n          cacheKey,\n          5 * 60 * 1000, // 5 minutos de TTL\n          { priority: true } // Prioridad alta para evitar evicción\n        );\n      } catch (error) {\n        console.error('Error fetching transaction from Supabase:', error);\n        // Si hay error, intentar obtener datos de IndexedDB\n        return await fetchFromIndexedDB();\n      }\n    } else {\n      // Si no hay conexión, obtener datos de IndexedDB\n      return await fetchFromIndexedDB();\n    }\n  } catch (error) {\n    console.error('Error in getTransactionById:', error);\n    return null;\n  }\n};\n\n// Alias para mantener compatibilidad\nexport const getTransaction = getTransactionById;\n\nexport const createTransaction = async (transaction) => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    // Validar la transacción\n    const validationResult = validateTransaction(transaction);\n    if (!validationResult.isValid) {\n      throw new Error(`Validation error: ${validationResult.errors.join(', ')}`);\n    }\n\n    // Eliminar el id si está presente para que Supabase lo genere automáticamente\n    // y manejar el campo platformType\n    const { id, platformType, ...transactionData } = transaction;\n\n    // Si no hay usuario, usar el almacenamiento local independiente\n    if (!user) {\n      console.log('No authenticated user found, using local storage');\n\n      // Preparar la transacción para almacenamiento local\n      const localTransaction = {\n        ...transactionData,\n        platform: platformType && transactionData.platform ?\n          `${platformType}:${transactionData.platform}` :\n          transactionData.platform,\n        user_id: DEMO_USER_ID,\n        id: id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        created_at: new Date().toISOString()\n      };\n\n      // Guardar en el almacenamiento local independiente\n      const success = addLocalTransaction(localTransaction);\n\n      if (success) {\n        console.log('Transaction saved to local storage:', localTransaction);\n        return localTransaction;\n      } else {\n        throw new Error('Error saving transaction to local storage');\n      }\n    }\n\n    console.log('Current user:', user);\n\n    // Agregar el ID del usuario a la transacción\n    // No usamos platform_type para evitar problemas con el caché de esquema\n    const transactionWithUserId = {\n      ...transactionData,\n      // Almacenamos el tipo de plataforma como parte del nombre de la plataforma\n      // Formato: \"TIPO:PLATAFORMA\" (ej. \"cash:Efectivo\" o \"virtual:Mercado Pago\")\n      platform: platformType && transactionData.platform ?\n        `${platformType}:${transactionData.platform}` :\n        transactionData.platform,\n      user_id: user.id,\n      // Generar un ID temporal para uso offline si no hay conexión\n      id: id || `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    };\n\n    console.log('Final transaction data:', transactionWithUserId);\n\n    // Función para actualizar el almacenamiento local\n    const updateLocalStorage = async (newTransaction) => {\n      try {\n        // Obtener transacciones actuales de localStorage\n        const currentTransactions = getTransactionsFromLocalStorage(user.id);\n\n        // Agregar la nueva transacción\n        const updatedTransactions = [newTransaction, ...currentTransactions];\n\n        // Guardar en localStorage\n        saveTransactionsToLocalStorage(user.id, updatedTransactions);\n\n        console.log('Transaction added to localStorage');\n      } catch (err) {\n        console.error('Error updating localStorage:', err);\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, crear la transacción en Supabase\n      const { data, error } = await supabase\n        .from('transactions')\n        .insert([transactionWithUserId])\n        .select();\n\n      if (error) {\n        console.error('Error creating transaction:', error);\n        console.error('Error details:', error.details, error.hint, error.message);\n\n        // Si el error es de clave foránea, es posible que el usuario no exista en la tabla auth.users\n        if (error.message.includes('violates foreign key constraint')) {\n          // Intentar crear un perfil para el usuario\n          const { error: profileError } = await supabase\n            .from('profiles')\n            .upsert([\n              {\n                id: user.id,\n                first_name: user.user_metadata?.first_name || user.user_metadata?.name?.split(' ')[0] || 'Usuario',\n                last_name: user.user_metadata?.last_name || user.user_metadata?.name?.split(' ').slice(1).join(' ') || '',\n                avatar_url: user.user_metadata?.avatar_url || null,\n                preferences: {}\n              }\n            ]);\n\n          if (profileError) {\n            console.error('Error creating profile:', profileError);\n\n            // Si hay error, guardar localmente y agregar a la cola de sincronización\n            await saveToIndexedDB('transactions', transactionWithUserId);\n            await addToSyncQueue({\n              type: 'CREATE',\n              storeName: 'transactions',\n              data: transactionWithUserId,\n            });\n\n            // Actualizar localStorage\n            await updateLocalStorage(transactionWithUserId);\n\n            // También guardar en el almacenamiento local independiente como respaldo\n            addLocalTransaction(transactionWithUserId);\n\n            // Invalidar la caché\n            removeCachedValue(`transactions_${user.id}`);\n\n            console.log('Transaction saved locally due to profile error:', transactionWithUserId);\n            return transactionWithUserId;\n          }\n\n          // Intentar nuevamente la inserción de la transacción\n          const { data: retryData, error: retryError } = await supabase\n            .from('transactions')\n            .insert([transactionWithUserId])\n            .select();\n\n          if (retryError) {\n            console.error('Error creating transaction (retry):', retryError);\n\n            // Si hay error en el reintento, guardar localmente\n            await saveToIndexedDB('transactions', transactionWithUserId);\n            await addToSyncQueue({\n              type: 'CREATE',\n              storeName: 'transactions',\n              data: transactionWithUserId,\n            });\n\n            // Actualizar localStorage\n            await updateLocalStorage(transactionWithUserId);\n\n            // También guardar en el almacenamiento local independiente como respaldo\n            addLocalTransaction(transactionWithUserId);\n\n            // Invalidar la caché\n            removeCachedValue(`transactions_${user.id}`);\n\n            console.log('Transaction saved locally after retry error:', transactionWithUserId);\n            return transactionWithUserId;\n          }\n\n          console.log('Transaction created successfully (after profile creation):', retryData?.[0]);\n\n          // Guardar en IndexedDB para acceso offline\n          if (retryData?.[0]) {\n            await saveToIndexedDB('transactions', retryData[0]);\n\n            // Actualizar localStorage\n            await updateLocalStorage(retryData[0]);\n\n            // También guardar en el almacenamiento local independiente como respaldo\n            addLocalTransaction(retryData[0]);\n          }\n\n          // Invalidar la caché\n          removeCachedValue(`transactions_${user.id}`);\n\n          return retryData?.[0] || null;\n        }\n\n        // Para otros errores, guardar localmente\n        await saveToIndexedDB('transactions', transactionWithUserId);\n        await addToSyncQueue({\n          type: 'CREATE',\n          storeName: 'transactions',\n          data: transactionWithUserId,\n        });\n\n        // Actualizar localStorage\n        await updateLocalStorage(transactionWithUserId);\n\n        // También guardar en el almacenamiento local independiente como respaldo\n        addLocalTransaction(transactionWithUserId);\n\n        // Invalidar la caché\n        removeCachedValue(`transactions_${user.id}`);\n\n        console.log('Transaction saved locally due to error:', transactionWithUserId);\n        return transactionWithUserId;\n      }\n\n      console.log('Transaction created successfully in Supabase:', data?.[0]);\n\n      // Guardar en IndexedDB para acceso offline\n      if (data?.[0]) {\n        await saveToIndexedDB('transactions', data[0]);\n\n        // Actualizar localStorage\n        await updateLocalStorage(data[0]);\n\n        // También guardar en el almacenamiento local independiente como respaldo\n        addLocalTransaction(data[0]);\n      }\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      return data?.[0] || null;\n    } else {\n      // Si no hay conexión, guardar localmente y agregar a la cola de sincronización\n      await saveToIndexedDB('transactions', transactionWithUserId);\n      await addToSyncQueue({\n        type: 'CREATE',\n        storeName: 'transactions',\n        data: transactionWithUserId,\n      });\n\n      // Actualizar localStorage\n      await updateLocalStorage(transactionWithUserId);\n\n      // También guardar en el almacenamiento local independiente como respaldo\n      addLocalTransaction(transactionWithUserId);\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      console.log('Transaction created locally (offline mode):', transactionWithUserId);\n      return transactionWithUserId;\n    }\n  } catch (error) {\n    console.error('Error in createTransaction:', error);\n\n    // Si hay un error, intentar guardar en el almacenamiento local independiente como último recurso\n    try {\n      if (transaction) {\n        const localTransaction = {\n          ...transaction,\n          id: transaction.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          user_id: DEMO_USER_ID,\n          created_at: new Date().toISOString()\n        };\n\n        const success = addLocalTransaction(localTransaction);\n\n        if (success) {\n          console.log('Transaction saved to local storage as fallback:', localTransaction);\n          return localTransaction;\n        }\n      }\n    } catch (err) {\n      console.error('Error saving to local storage as fallback:', err);\n    }\n\n    throw error;\n  }\n};\n\nexport const updateTransaction = async (id, updates) => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    // Si no hay usuario, lanzar un error\n    if (!user) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Obtener la transacción actual para validarla con los cambios\n    // Primero intentar obtenerla de IndexedDB\n    let currentTransaction;\n\n    try {\n      currentTransaction = await getFromIndexedDB('transactions', id);\n    } catch (err) {\n      console.log('Transaction not found in IndexedDB, trying Supabase');\n    }\n\n    // Si no se encuentra en IndexedDB, intentar obtenerla de Supabase\n    if (!currentTransaction) {\n      currentTransaction = await getTransaction(id);\n    }\n\n    if (!currentTransaction) {\n      throw new Error('Transaction not found');\n    }\n\n    // Verificar que la transacción pertenece al usuario\n    if (currentTransaction.user_id !== user.id) {\n      throw new Error('You do not have permission to update this transaction');\n    }\n\n    // Crear una transacción completa para validación\n    const transactionToValidate = {\n      ...currentTransaction,\n      ...updates\n    };\n\n    // Validar la transacción\n    const validationResult = validateTransaction(transactionToValidate);\n    if (!validationResult.isValid) {\n      throw new Error(`Validation error: ${validationResult.errors.join(', ')}`);\n    }\n\n    // Manejar el campo platformType\n    const { platformType, ...updateData } = updates;\n\n    // No usamos platform_type para evitar problemas con el caché de esquema\n    // En su lugar, almacenamos el tipo de plataforma como parte del nombre de la plataforma\n    const finalUpdates = (platformType && updateData.platform)\n      ? {\n          ...updateData,\n          // Formato: \"TIPO:PLATAFORMA\" (ej. \"cash:Efectivo\" o \"virtual:Mercado Pago\")\n          platform: `${platformType}:${updateData.platform}`\n        }\n      : updateData;\n\n    console.log('Updating transaction with data:', finalUpdates);\n\n    // Función para actualizar el almacenamiento local\n    const updateLocalStorage = async (updatedTransaction) => {\n      try {\n        // Obtener transacciones actuales de localStorage\n        const currentTransactions = getTransactionsFromLocalStorage(user.id);\n\n        // Reemplazar la transacción actualizada\n        const updatedTransactions = currentTransactions.map(t =>\n          t.id === updatedTransaction.id ? updatedTransaction : t\n        );\n\n        // Guardar en localStorage\n        saveTransactionsToLocalStorage(user.id, updatedTransactions);\n\n        console.log('Transaction updated in localStorage');\n      } catch (err) {\n        console.error('Error updating localStorage:', err);\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, actualizar en Supabase\n      const { data, error } = await supabase\n        .from('transactions')\n        .update(finalUpdates)\n        .eq('id', id)\n        .select();\n\n      if (error) {\n        console.error('Error updating transaction in Supabase:', error);\n        console.error('Error details:', error.details, error.hint, error.message);\n\n        // Si hay error, actualizar localmente y agregar a la cola de sincronización\n        const updatedTransaction = {\n          ...currentTransaction,\n          ...finalUpdates\n        };\n\n        await saveToIndexedDB('transactions', updatedTransaction);\n        await addToSyncQueue({\n          type: 'UPDATE',\n          storeName: 'transactions',\n          data: updatedTransaction,\n        });\n\n        // Actualizar localStorage\n        await updateLocalStorage(updatedTransaction);\n\n        // Invalidar la caché\n        removeCachedValue(`transactions_${user.id}`);\n\n        console.log('Transaction updated locally due to error:', updatedTransaction);\n        return updatedTransaction;\n      }\n\n      console.log('Transaction updated successfully in Supabase:', data?.[0]);\n\n      // Actualizar en IndexedDB para acceso offline\n      if (data?.[0]) {\n        await saveToIndexedDB('transactions', data[0]);\n\n        // Actualizar localStorage\n        await updateLocalStorage(data[0]);\n      }\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      return data?.[0] || null;\n    } else {\n      // Si no hay conexión, actualizar localmente y agregar a la cola de sincronización\n      const updatedTransaction = {\n        ...currentTransaction,\n        ...finalUpdates\n      };\n\n      await saveToIndexedDB('transactions', updatedTransaction);\n      await addToSyncQueue({\n        type: 'UPDATE',\n        storeName: 'transactions',\n        data: updatedTransaction,\n      });\n\n      // Actualizar localStorage\n      await updateLocalStorage(updatedTransaction);\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      console.log('Transaction updated locally (offline mode):', updatedTransaction);\n      return updatedTransaction;\n    }\n  } catch (error) {\n    console.error('Error in updateTransaction:', error);\n    throw error;\n  }\n};\n\n/**\n * Elimina una transacción\n * @param {number} id - ID de la transacción\n * @returns {Promise<boolean>} - true si se eliminó correctamente\n */\nexport const deleteTransaction = async (id) => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Verificar que la transacción pertenece al usuario\n    // Primero intentar obtenerla de IndexedDB\n    let transaction;\n\n    try {\n      transaction = await getFromIndexedDB('transactions', id);\n    } catch (err) {\n      console.log('Transaction not found in IndexedDB, trying Supabase');\n    }\n\n    // Si no se encuentra en IndexedDB, intentar obtenerla de Supabase\n    if (!transaction) {\n      transaction = await getTransactionById(id);\n    }\n\n    if (!transaction) {\n      throw new Error('Transaction not found or you do not have permission to delete it');\n    }\n\n    // Verificar que la transacción pertenece al usuario\n    if (transaction.user_id !== user.id) {\n      throw new Error('You do not have permission to delete this transaction');\n    }\n\n    // Función para actualizar el almacenamiento local\n    const updateLocalStorage = async () => {\n      try {\n        // Obtener transacciones actuales de localStorage\n        const currentTransactions = getTransactionsFromLocalStorage(user.id);\n\n        // Filtrar la transacción eliminada\n        const updatedTransactions = currentTransactions.filter(t => t.id !== id);\n\n        // Guardar en localStorage\n        saveTransactionsToLocalStorage(user.id, updatedTransactions);\n\n        console.log('Transaction removed from localStorage');\n      } catch (err) {\n        console.error('Error updating localStorage:', err);\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, eliminar en Supabase\n      const { error } = await supabase\n        .from('transactions')\n        .delete()\n        .eq('id', id)\n        .eq('user_id', user.id);\n\n      if (error) {\n        console.error('Error deleting transaction from Supabase:', error);\n\n        // Si hay error, marcar como eliminada localmente y agregar a la cola de sincronización\n        await deleteFromIndexedDB('transactions', id);\n        await addToSyncQueue({\n          type: 'DELETE',\n          storeName: 'transactions',\n          data: { id, user_id: user.id },\n        });\n\n        // Actualizar localStorage\n        await updateLocalStorage();\n\n        // Invalidar la caché\n        removeCachedValue(`transactions_${user.id}`);\n\n        console.log('Transaction marked for deletion locally due to error');\n        return true;\n      }\n\n      // Si se eliminó correctamente, eliminar también de IndexedDB\n      await deleteFromIndexedDB('transactions', id);\n\n      // Actualizar localStorage\n      await updateLocalStorage();\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      console.log('Transaction deleted successfully from Supabase and IndexedDB');\n      return true;\n    } else {\n      // Si no hay conexión, marcar como eliminada localmente y agregar a la cola de sincronización\n      await deleteFromIndexedDB('transactions', id);\n      await addToSyncQueue({\n        type: 'DELETE',\n        storeName: 'transactions',\n        data: { id, user_id: user.id },\n      });\n\n      // Actualizar localStorage\n      await updateLocalStorage();\n\n      // Invalidar la caché\n      removeCachedValue(`transactions_${user.id}`);\n\n      console.log('Transaction marked for deletion locally (offline mode)');\n      return true;\n    }\n  } catch (error) {\n    console.error('Error in deleteTransaction:', error);\n    throw error;\n  }\n};\n\nexport const getTransactionsByType = async (type) => {\n  const { data, error } = await supabase\n    .from('transactions')\n    .select('*')\n    .eq('type', type)\n    .order('date', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching ${type} transactions:`, error);\n    return [];\n  }\n\n  return data || [];\n};\n\nexport const getTransactionsByCategory = async (category) => {\n  const { data, error } = await supabase\n    .from('transactions')\n    .select('*')\n    .eq('category', category)\n    .order('date', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching transactions for category ${category}:`, error);\n    return [];\n  }\n\n  return data || [];\n};\n\nexport const getTransactionsByDateRange = async (startDate, endDate) => {\n  const { data, error } = await supabase\n    .from('transactions')\n    .select('*')\n    .gte('date', startDate)\n    .lte('date', endDate)\n    .order('date', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching transactions for date range:`, error);\n    return [];\n  }\n\n  return data || [];\n};\n\n/**\n * Obtiene transacciones con paginación para carga progresiva\n * @param {Object} options - Opciones de paginación y filtrado\n * @param {number} options.start - Índice de inicio\n * @param {number} options.end - Índice de fin\n * @param {Object} options.filters - Filtros a aplicar\n * @param {Object} options.sort - Configuración de ordenamiento\n * @returns {Promise<Object>} - Datos paginados y metadatos\n */\nexport const getTransactionsPaginated = async ({ start = 0, end = 10, filters = {}, sort = { column: 'date', direction: 'desc' } }) => {\n  try {\n    // Obtener el usuario actual\n    const { data: { user } } = await supabase.auth.getUser();\n\n    if (!user) {\n      throw new Error('No authenticated user found');\n    }\n\n    // Construir clave de caché basada en parámetros\n    const filterKey = JSON.stringify(filters);\n    const sortKey = JSON.stringify(sort);\n    const cacheKey = `transactions_paginated_${user.id}_${start}_${end}_${filterKey}_${sortKey}`;\n\n    // Función para obtener datos de Supabase\n    const fetchFromSupabase = async () => {\n      // Construir consulta base\n      let query = supabase\n        .from('transactions')\n        .select('*', { count: 'exact' })\n        .eq('user_id', user.id);\n\n      // Aplicar filtros\n      if (filters.type) {\n        query = query.eq('type', filters.type);\n      }\n\n      if (filters.category) {\n        query = query.eq('category', filters.category);\n      }\n\n      if (filters.platform) {\n        query = query.eq('platform', filters.platform);\n      }\n\n      if (filters.startDate) {\n        query = query.gte('date', filters.startDate);\n      }\n\n      if (filters.endDate) {\n        query = query.lte('date', filters.endDate);\n      }\n\n      if (filters.minAmount) {\n        query = query.gte('amount', filters.minAmount);\n      }\n\n      if (filters.maxAmount) {\n        query = query.lte('amount', filters.maxAmount);\n      }\n\n      if (filters.search) {\n        query = query.ilike('title', `%${filters.search}%`);\n      }\n\n      // Aplicar ordenamiento\n      query = query.order(sort.column, { ascending: sort.direction === 'asc' });\n\n      // Aplicar paginación\n      query = query.range(start, end - 1);\n\n      // Ejecutar consulta\n      const { data, error, count } = await query;\n\n      if (error) {\n        throw error;\n      }\n\n      return {\n        data: data || [],\n        count: count || 0,\n        hasMore: (count || 0) > end\n      };\n    };\n\n    // Función para obtener datos de IndexedDB\n    const fetchFromIndexedDB = async () => {\n      try {\n        // Obtener todos los datos\n        const allData = await getFromIndexedDB('transactions');\n\n        // Filtrar por usuario\n        let filteredData = allData.filter(t => t.user_id === user.id);\n\n        // Aplicar filtros\n        if (filters.type) {\n          filteredData = filteredData.filter(t => t.type === filters.type);\n        }\n\n        if (filters.category) {\n          filteredData = filteredData.filter(t => t.category === filters.category);\n        }\n\n        if (filters.platform) {\n          filteredData = filteredData.filter(t => t.platform === filters.platform);\n        }\n\n        if (filters.startDate) {\n          filteredData = filteredData.filter(t => t.date >= filters.startDate);\n        }\n\n        if (filters.endDate) {\n          filteredData = filteredData.filter(t => t.date <= filters.endDate);\n        }\n\n        if (filters.minAmount) {\n          filteredData = filteredData.filter(t => t.amount >= filters.minAmount);\n        }\n\n        if (filters.maxAmount) {\n          filteredData = filteredData.filter(t => t.amount <= filters.maxAmount);\n        }\n\n        if (filters.search) {\n          const searchLower = filters.search.toLowerCase();\n          filteredData = filteredData.filter(t =>\n            t.title && t.title.toLowerCase().includes(searchLower)\n          );\n        }\n\n        // Aplicar ordenamiento\n        filteredData.sort((a, b) => {\n          const aValue = a[sort.column];\n          const bValue = b[sort.column];\n\n          if (sort.direction === 'asc') {\n            return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;\n          } else {\n            return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;\n          }\n        });\n\n        // Aplicar paginación\n        const paginatedData = filteredData.slice(start, end);\n\n        return {\n          data: paginatedData,\n          count: filteredData.length,\n          hasMore: filteredData.length > end\n        };\n      } catch (err) {\n        console.error('Error fetching from IndexedDB:', err);\n        return { data: [], count: 0, hasMore: false };\n      }\n    };\n\n    // Verificar si hay conexión a Internet\n    if (checkOnlineStatus()) {\n      // Si hay conexión, intentar obtener datos con caché\n      try {\n        // Usar withCache para manejar automáticamente la caché\n        return await withCache(\n          fetchFromSupabase,\n          cacheKey,\n          2 * 60 * 1000, // 2 minutos de TTL\n          { priority: false } // Prioridad normal\n        );\n      } catch (error) {\n        console.error('Error fetching paginated transactions from Supabase:', error);\n        // Si hay error, intentar obtener datos de IndexedDB\n        return await fetchFromIndexedDB();\n      }\n    } else {\n      // Si no hay conexión, obtener datos de IndexedDB\n      return await fetchFromIndexedDB();\n    }\n  } catch (error) {\n    console.error('Error in getTransactionsPaginated:', error);\n    return { data: [], count: 0, hasMore: false };\n  }\n};\n","/**\n * Servicio de caché avanzado para optimizar consultas a la base de datos\n */\n\n// Caché en memoria\nconst memoryCache = new Map();\n\n// Configuración de caché\nconst DEFAULT_TTL = 5 * 60 * 1000; // 5 minutos\nconst MAX_CACHE_SIZE = 100; // Máximo número de entradas en caché\nconst CACHE_CLEANUP_INTERVAL = 10 * 60 * 1000; // 10 minutos\n\n// Estadísticas de caché\nlet cacheHits = 0;\nlet cacheMisses = 0;\nlet cacheEvictions = 0;\n\n/**\n * Obtener valor de la caché\n * @param {string} key - Clave de caché\n * @returns {any|null} - Valor almacenado o null si no existe o expiró\n */\nexport const getCachedValue = (key) => {\n  const cacheEntry = memoryCache.get(key);\n  \n  if (!cacheEntry) {\n    cacheMisses++;\n    return null;\n  }\n  \n  // Verificar si el valor ha expirado\n  if (cacheEntry.expiresAt && Date.now() > cacheEntry.expiresAt) {\n    memoryCache.delete(key);\n    cacheMisses++;\n    return null;\n  }\n  \n  // Actualizar estadísticas de acceso\n  cacheEntry.lastAccessed = Date.now();\n  cacheEntry.accessCount++;\n  cacheHits++;\n  \n  return cacheEntry.value;\n};\n\n/**\n * Almacenar valor en la caché\n * @param {string} key - Clave de caché\n * @param {any} value - Valor a almacenar\n * @param {number} ttl - Tiempo de vida en milisegundos (opcional)\n * @param {Object} options - Opciones adicionales\n * @param {boolean} options.priority - Prioridad alta (no se eliminará en limpiezas automáticas)\n * @returns {boolean} - true si se almacenó correctamente\n */\nexport const setCachedValue = (key, value, ttl = DEFAULT_TTL, options = {}) => {\n  // Verificar si es necesario limpiar la caché\n  if (memoryCache.size >= MAX_CACHE_SIZE) {\n    evictCacheEntries();\n  }\n  \n  // Calcular tiempo de expiración\n  const expiresAt = ttl > 0 ? Date.now() + ttl : null;\n  \n  // Almacenar valor en caché\n  memoryCache.set(key, {\n    value,\n    expiresAt,\n    createdAt: Date.now(),\n    lastAccessed: Date.now(),\n    accessCount: 0,\n    priority: options.priority || false\n  });\n  \n  return true;\n};\n\n/**\n * Eliminar valor de la caché\n * @param {string} key - Clave de caché\n * @returns {boolean} - true si se eliminó correctamente\n */\nexport const removeCachedValue = (key) => {\n  return memoryCache.delete(key);\n};\n\n/**\n * Limpiar toda la caché\n * @returns {boolean} - true si se limpió correctamente\n */\nexport const clearCache = () => {\n  memoryCache.clear();\n  return true;\n};\n\n/**\n * Ejecutar función con caché\n * @param {Function} fn - Función a ejecutar\n * @param {string} key - Clave de caché\n * @param {number} ttl - Tiempo de vida en milisegundos (opcional)\n * @param {Object} options - Opciones adicionales\n * @returns {Promise<any>} - Resultado de la función\n */\nexport const withCache = async (fn, key, ttl = DEFAULT_TTL, options = {}) => {\n  // Verificar si el valor está en caché\n  const cachedValue = getCachedValue(key);\n  \n  if (cachedValue !== null) {\n    return cachedValue;\n  }\n  \n  // Ejecutar función\n  const result = await fn();\n  \n  // Almacenar resultado en caché\n  setCachedValue(key, result, ttl, options);\n  \n  return result;\n};\n\n/**\n * Eliminar entradas de caché según política de evicción\n * @private\n */\nconst evictCacheEntries = () => {\n  // No eliminar si la caché no está llena\n  if (memoryCache.size < MAX_CACHE_SIZE) {\n    return;\n  }\n  \n  // Convertir Map a Array para ordenar\n  const entries = Array.from(memoryCache.entries());\n  \n  // Filtrar entradas con prioridad alta\n  const normalEntries = entries.filter(([_, entry]) => !entry.priority);\n  \n  // Si no hay entradas normales, no eliminar nada\n  if (normalEntries.length === 0) {\n    return;\n  }\n  \n  // Ordenar por último acceso (más antiguo primero)\n  normalEntries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);\n  \n  // Eliminar el 20% de las entradas más antiguas\n  const entriesToRemove = Math.max(1, Math.floor(normalEntries.length * 0.2));\n  \n  for (let i = 0; i < entriesToRemove; i++) {\n    if (i < normalEntries.length) {\n      memoryCache.delete(normalEntries[i][0]);\n      cacheEvictions++;\n    }\n  }\n};\n\n/**\n * Obtener estadísticas de caché\n * @returns {Object} - Estadísticas de caché\n */\nexport const getCacheStats = () => {\n  return {\n    size: memoryCache.size,\n    hits: cacheHits,\n    misses: cacheMisses,\n    evictions: cacheEvictions,\n    hitRatio: cacheHits + cacheMisses > 0 ? cacheHits / (cacheHits + cacheMisses) : 0\n  };\n};\n\n/**\n * Prefetch de datos en caché\n * @param {Function} fn - Función para obtener datos\n * @param {string} key - Clave de caché\n * @param {number} ttl - Tiempo de vida en milisegundos (opcional)\n * @returns {Promise<boolean>} - true si se completó correctamente\n */\nexport const prefetchCache = async (fn, key, ttl = DEFAULT_TTL) => {\n  try {\n    const result = await fn();\n    setCachedValue(key, result, ttl);\n    return true;\n  } catch (error) {\n    console.error('Error en prefetch de caché:', error);\n    return false;\n  }\n};\n\n// Iniciar limpieza periódica de caché\nsetInterval(() => {\n  const now = Date.now();\n  \n  // Eliminar entradas expiradas\n  for (const [key, entry] of memoryCache.entries()) {\n    if (entry.expiresAt && now > entry.expiresAt) {\n      memoryCache.delete(key);\n    }\n  }\n}, CACHE_CLEANUP_INTERVAL);\n","import React from 'react';\nimport styled from 'styled-components';\nimport { useSpring, animated } from 'react-spring';\n\n// Estilos para el botón\nconst ButtonContainer = styled(animated.button)`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 10px 20px;\n  border-radius: var(--border-radius);\n  font-weight: 500;\n  font-size: 0.9rem;\n  cursor: pointer;\n  transition: background-color 0.2s, transform 0.1s;\n  border: none;\n  outline: none;\n  gap: 8px;\n  \n  &:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n  }\n  \n  ${props => props.variant === 'primary' && `\n    background-color: var(--primary-color);\n    color: white;\n    \n    &:hover:not(:disabled) {\n      background-color: var(--primary-color-dark);\n    }\n  `}\n  \n  ${props => props.variant === 'secondary' && `\n    background-color: var(--secondary-color);\n    color: white;\n    \n    &:hover:not(:disabled) {\n      background-color: var(--secondary-color-dark);\n    }\n  `}\n  \n  ${props => props.variant === 'danger' && `\n    background-color: var(--danger-color);\n    color: white;\n    \n    &:hover:not(:disabled) {\n      background-color: var(--danger-color-dark);\n    }\n  `}\n  \n  ${props => props.variant === 'outline' && `\n    background-color: transparent;\n    color: var(--primary-color);\n    border: 1px solid var(--primary-color);\n    \n    &:hover:not(:disabled) {\n      background-color: rgba(var(--primary-color-rgb), 0.1);\n    }\n  `}\n  \n  ${props => props.fullWidth && `\n    width: 100%;\n  `}\n`;\n\n/**\n * Componente de botón con animación\n * @param {Object} props - Propiedades del componente\n * @param {string} props.variant - Variante del botón (primary, secondary, danger, outline)\n * @param {boolean} props.fullWidth - Si el botón debe ocupar todo el ancho disponible\n * @param {boolean} props.disabled - Si el botón está deshabilitado\n * @param {Function} props.onClick - Función a ejecutar al hacer clic en el botón\n * @param {React.ReactNode} props.children - Contenido del botón\n * @returns {JSX.Element} - Componente de botón animado\n */\nconst AnimatedButton = ({ \n  variant = 'primary', \n  fullWidth = false, \n  disabled = false, \n  onClick, \n  children,\n  ...rest \n}) => {\n  // Animación al pasar el mouse por encima\n  const [springs, api] = useSpring(() => ({\n    scale: 1,\n    config: { tension: 300, friction: 10 }\n  }));\n  \n  // Manejadores de eventos\n  const handleMouseEnter = () => {\n    if (!disabled) {\n      api.start({ scale: 1.05 });\n    }\n  };\n  \n  const handleMouseLeave = () => {\n    api.start({ scale: 1 });\n  };\n  \n  const handleClick = (e) => {\n    if (!disabled && onClick) {\n      // Animación al hacer clic\n      api.start({\n        scale: 0.95,\n        onRest: () => {\n          api.start({ scale: 1 });\n          onClick(e);\n        }\n      });\n    }\n  };\n  \n  return (\n    <ButtonContainer\n      variant={variant}\n      fullWidth={fullWidth}\n      disabled={disabled}\n      onClick={handleClick}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      style={springs}\n      {...rest}\n    >\n      {children}\n    </ButtonContainer>\n  );\n};\n\nexport default AnimatedButton;\n"],"names":["validateTransaction","transaction","result","isValid","errors","title","trim","push","amount","isNaN","type","includes","date","STORAGE_PREFIX","saveTransactionsToLocalStorage","userId","transactions","console","error","data","timestamp","Date","now","count","length","key","localStorage","setItem","JSON","stringify","log","getTransactionsFromLocalStorage","storedData","getItem","parse","Math","round","DEMO_USER_ID","saveLocalData","fullKey","dataToSave","getLocalData","defaultValue","arguments","undefined","parsedData","saveTransactions","getTransactions","addTransaction","transactionWithId","id","random","toString","substr","user_id","created_at","toISOString","updatedTransactions","async","user","supabase","auth","getUser","localTransactions","getLocalTransactions","cacheKey","localStorageData","initialData","fetchFromSupabase","from","select","eq","order","ascending","saveToIndexedDB","fetchFromIndexedDB","localData","getFromIndexedDB","userTransactions","filter","t","err","checkOnlineStatus","finalData","setCachedValue","priority","onlineData","withCache","indexedDBData","getTransactionById","Error","single","getTransaction","createTransaction","validationResult","join","platformType","transactionData","localTransaction","platform","addLocalTransaction","transactionWithUserId","updateLocalStorage","newTransaction","insert","details","hint","message","_user$user_metadata","_user$user_metadata2","_user$user_metadata2$","_user$user_metadata3","_user$user_metadata4","_user$user_metadata4$","_user$user_metadata5","profileError","upsert","first_name","user_metadata","name","split","last_name","slice","avatar_url","preferences","addToSyncQueue","storeName","removeCachedValue","retryData","retryError","updateTransaction","updates","currentTransaction","transactionToValidate","updateData","finalUpdates","map","updatedTransaction","update","deleteTransaction","delete","deleteFromIndexedDB","getTransactionsPaginated","start","end","filters","sort","column","direction","_ref","filterKey","sortKey","query","category","startDate","gte","endDate","lte","minAmount","maxAmount","search","ilike","range","hasMore","filteredData","searchLower","toLowerCase","a","b","aValue","bValue","memoryCache","Map","DEFAULT_TTL","value","ttl","options","size","evictCacheEntries","expiresAt","set","createdAt","lastAccessed","accessCount","fn","cachedValue","cacheEntry","get","getCachedValue","normalEntries","Array","entries","_","entry","entriesToRemove","max","floor","i","setInterval","ButtonContainer","styled","animated","button","props","variant","fullWidth","disabled","onClick","children","rest","springs","api","useSpring","scale","config","tension","friction","_jsx","e","onRest","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","style"],"sourceRoot":""}